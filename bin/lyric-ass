#!/usr/bin/env node

var fs = require('fs')
var parseArgs = require('minimist')
var lyric_dl = require('../index.js')
var ass = require('../lib/ass/ass')
var editcode = require('../lib/ass/editcode')

var args = parseArgs(process.argv)

if (args['h'] || args['help']) {
    console.log("\
ASS format lyrics generator.\n\
\n\
Usage: lyric-ass [OPTIONS] [url | filename]\n\
\n\
OPTIONS: \n\
    -e --edit-args=<commands>\n\
    -E --edit-mode\n\
    -h --help\n\
    --frame-size=<size>\n\
    --max-duration\n\
\n\
EDIT COMMANDS:\n\
    \"1d,4+1.33,5-1.3\"\n\
    <range|index> s             delete lyrics\n\
")
    process.exit(0)
}

function numberToIndex(length, n) {
    n = parseInt(n)

    if (n == 0) {
        throw `invalid index number ${n}`
    }

    if (n < 0) {
        n = Math.max(length - Math.abs(n), 0)
    } else {
        n -= 1
    }

    return n
}

function checkArgs(args, count, types) {
    if (count != null && args.length != count) {
        throw `need count ${count}, but given ${args.length} argument(s)`
    }

    var ret = []

    args.forEach((v, k) => {
        var needType = types ? types[k] : null

        switch (needType) {
            case 'number':
                var _v = parseFloat(v)

                if (Number.isNaN(_v)) {
                    throw `bad argument #${k}, failed convert to a number`
                }

                ret.push(_v)
                break
            default:
                ret.push(v)
        }
    })

    return ret
}

function getLyricsFromTarget(lyrics, target) {
    var ret = []

    switch(target.type) 
    {
        case 'range':
            var begin = numberToIndex(lyrics.length, target.content[0])
            var end = numberToIndex(lyrics.length, target.content[1])

            if (begin > end) {
                break
            }

            for(var i = begin; i <= end; i++) {
                if (lyrics[i]) {
                    ret.push(lyrics[i])
                } else {
                    break
                }
            }

            break
        case 'index':
            target.content.forEach((v) => {
                var line = lyrics[numberToIndex(lyrics.length, v)]
                if (line) {
                    ret.push(line)
                }
            })
            break
        default:
            break
    }

    return ret
}

function applyCommand(lyrics, commandsString) {
    if (!commandsString) {
        return lyrics
    }

    var cmds = editcode.parseCode(commandsString)

    cmds.forEach((cmd, index) => {
        var target

        try
        {
            target = getLyricsFromTarget(lyrics, cmd.target)
        } catch (e) {
            throw `${e} in command: (#${index+1}) '${cmd.raw}'`
        }

        try
        {
            switch (cmd.command) {
                case 'd':
                    var args = checkArgs(cmd.args, 0, null)

                    target.forEach((lyric) => {
                        lyric._del_mark = true
                    })
                    break
                case '>':
                    var args = checkArgs(cmd.args, 1, ['number'])

                    target.forEach((lyric) => {
                        lyric.time = lyric.time + args[0]
                    })
                    break
                case '<':
                    var args = checkArgs(cmd.args, 1, ['number'])

                    target.forEach((lyric) => {
                        lyric.time = lyric.time - args[0]
                    })
                    break
                case '+':
                    var args = checkArgs(cmd.args, 1, ['number'])

                    target.forEach((lyric) => {
                        lyric.durationTime = lyric.durationTime + args[0]
                    })
                    break
                case '-':
                    var args = checkArgs(cmd.args, 1, ['number'])

                    target.forEach((lyric) => {
                        lyric.durationTime = lyric.durationTime - args[0]
                    })
                    break
                default:
                    throw `unknown type '${cmd.command}'`
            }
        } catch (e) {
            throw `${e}: (#${index+1})'${cmd.raw}'`
        }
    })

    var new_lyrics = []

    lyrics.forEach((lyric) => {
        if (!lyric._del_mark) {
            lyric.time = Math.max(lyric.time, 0)
            lyric.durationTime = Math.max(lyric.durationTime, 0)
            new_lyrics.push(lyric)
        }
    })

    new_lyrics.sort((a, b) => {
        return a.time - b.time
    })

    return new_lyrics
}

function handleSong(songInfo, args) {
    if (!songInfo.lrc) {
        console.error('lyrics data not exists')
        process.exit(2)
    }

    // set translate to map
    if (songInfo.tlrc) {
        var tlrc_map = {}
        
        songInfo.tlrc.forEach((v, k) => {
            tlrc_map[v[0]] = v[1]
        })
    }

    var maxDurationTime = 6

    if (args['max-duration'] != null) {
        var maxDurationTimeVal = args['max-duration']

        maxDurationTime = parseFloat(maxDurationTimeVal)

        if (Number.isNaN(maxDurationTime)) {
            console.error(`argument --max-duration: invalid number '${maxDurationTimeVal}'`)
            process.exit(2)
        }

        if (maxDurationTime <= 0) {
            console.error('argument --max-duration: must greater than 0')
            process.exit(2)
        }
    }

    var lyrics = []

    var isEditMode = (args['E'] || args['edit-mode']) ? true : false
    var length = songInfo.lrc.length

    // convert time string to float number and merge lyrics
    songInfo.lrc.forEach((v, k) => {
        var m = v[0].match(/^(\d+):(\d+\.\d+)$/)
        if (!m || m.length != 3)
            throw `failed match time: "${e}"`

        lyrics.push({
            'raw_index': k,
            'origalTime': v[0],
            'time': parseInt(m[1]) * 60 + parseFloat(m[2]) + 0.7  , 
            'text': (isEditMode ? `#${k + 1}/${length} ` : '') + v[1],
            'translate': tlrc_map[v[0]],
        })
    })

    for (var i = 0; i != lyrics.length; i++) {
        var thisLine = lyrics[i]
        var lastLine = lyrics[i + 1]

        if (lastLine) {
            thisLine.durationTime = Math.min(lastLine.time - thisLine.time, maxDurationTime)
        } else {
            thisLine.durationTime = maxDurationTime
        }
    }

    lyrics = applyCommand(lyrics, args['e'] || args['edit-args'])

    var assGenerator = new ass.ASSGenerator({
        'title': '??',
    })

    assGenerator.createStyle({
        'name': 'style_1',
        'fontName': 'Apple SD Gothic Neo',
        'fontSize': 40,
    })

    assGenerator.createStyle({
        'name': 'style_2',
        'fontName': 'Apple SD Gothic Neo',
        'fontSize': 50,
    })

    var textPos = assGenerator.toRelativePos([150, 928], [1920, 1080])
    var translatePos = assGenerator.toRelativePos([150, 980], [1920, 1080])
    var moveStep = assGenerator.toRelativePos([10, 0], [1920, 1080])

    var textEffect = assGenerator.fadEffect(80,80) + assGenerator.moveEffect(
        [textPos[0] - moveStep[0], textPos[1]],
        [textPos[0] + moveStep[0] * 2, textPos[1]])

    var translateEffect = assGenerator.fadEffect(80,80) + assGenerator.moveEffect(
        translatePos,
        [translatePos[0] + moveStep[0] * 2, translatePos[1]])

    lyrics.forEach((v) => {
        if (v.text) {
            assGenerator.createEvent({
                'start': v.time,
                'end': v.time + v.durationTime,
                'style': 'style_1',
                'text':  textEffect + v.text,
            })
        }

        if (v.translate) {
            assGenerator.createEvent({
                'start': v.time,
                'end': v.time + v.durationTime,
                'style': 'style_2',
                'text': translateEffect + v.translate,
            })
        }
    })

    fs.writeFile(`${songInfo.name}.ass`, assGenerator.getContent(), (err) => {
        if (err) throw err;
        process.exit(0)
    })
    
}

if (args['_'].length < 3) {
    console.error('no url or filename input')
} else if (args['_'].length > 3) {
    console.error('can\'t input multiple url or filename ')
}

var url = args['_'][2]

try{
    var info = lyric_dl.getLoaderFromUrl(url)
} catch (e) {
    console.error(`${e}: "${url}"`)
    process.exit(2)
}

info.loader.download({ 
    id: info.id, 
    extract: true
}, function (result) {
    if (result.err) {
        console.error(`request error: ${result.err}`)
        process.exit(2)
    }

    setTimeout(handleSong, 0, result, args)
})